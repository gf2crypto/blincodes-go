package vector

import (
	"testing"
)

func TestNew(t *testing.T) {
	v := New()
	if v.body != nil {
		t.Errorf("TestNew: expected New().body == nil, but got %v", v.body)
	}
	if v.lenLast != WordSize {
		t.Errorf("TestNew: expected New().lenLast == %d, but got %d", WordSize, v.lenLast)
	}
}

func TestVector_SetZero(t *testing.T) {
	var testCases = [][]interface{}{
		{uint(00), ""},
		{uint(01), "0"},
		{uint(05), "00000"},
		{uint(63), "000000000000000000000000000000000000000000000000000000000000000"},
		{uint(64), "0000000000000000000000000000000000000000000000000000000000000000"},
		{uint(65), "00000000000000000000000000000000000000000000000000000000000000000"},
		{uint(75), "000000000000000000000000000000000000000000000000000000000000000000000000000"},
		{uint(76), "0000000000000000000000000000000000000000000000000000000000000000000000000000"},
	}
	for _, tc := range testCases {
		v := new(Vector).SetZero(tc[0].(uint))
		if v.String() != tc[1].(string) {
			t.Errorf("v.SetZero(%d) == %s, expected %s", tc[0], v, tc[1])
		}
	}
}

func TestVector_SetUnits(t *testing.T) {
	var testCases = [][]interface{}{
		{uint(00), ""},
		{uint(01), "1"},
		{uint(05), "11111"},
		{uint(63), "111111111111111111111111111111111111111111111111111111111111111"},
		{uint(64), "1111111111111111111111111111111111111111111111111111111111111111"},
		{uint(65), "11111111111111111111111111111111111111111111111111111111111111111"},
		{uint(75), "111111111111111111111111111111111111111111111111111111111111111111111111111"},
		{uint(76), "1111111111111111111111111111111111111111111111111111111111111111111111111111"},
	}
	for _, tc := range testCases {
		v := new(Vector).SetUnits(tc[0].(uint))
		if v.String() != tc[1].(string) {
			t.Errorf("v.SetZero(%d) == %s, expected %s", tc[0], v, tc[1])
		}
	}
}

func TestVector_SetBytes(t *testing.T) {
	b := []byte{
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xEF, 0x98,
	}
	var testCases = [][]interface{}{
		{b, uint(80), "00000001001000110100010101100111100010011010101111001101111011111110111110011000"},
		{b, uint(61), "0000000100100011010001010110011110001001101010111100110111101"},
		{b, uint(65), "00000001001000110100010101100111100010011010101111001101111011111"},
		{b[5:6], uint(03), "101"},
		{make([]byte, 0), uint(05), "00000"},
	}
	for _, tc := range testCases {
		v := new(Vector).SetBytes(tc[0].([]byte), tc[1].(uint))
		if v.String() != tc[2].(string) {
			t.Errorf("v.SetBytes(%v, %d) == %s, expected %s", tc[0], tc[1], v, tc[2])
		}
	}
}

func TestVector_SetBitArray(t *testing.T) {
	var testCases = [][]interface{}{
		{nil, ""},
		{[]byte{}, ""},
		{[]byte{0}, "0"},
		{[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}, "11111111111111110000000011111111"},
		{[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}, "1111111111111111000000001111111100001111000011110011001100110011"},
		{[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}, "111111111111111100000000111111110000111100001111001100110011001101010101010101010000111111111"},
	}
	for _, tc := range testCases {
		var v *Vector
		switch tc[0].(type) {
		case nil:
			v = new(Vector).SetBitArray(nil)
		default:
			v = new(Vector).SetBitArray(tc[0].([]byte))
		}
		if v.String() != tc[1].(string) {
			t.Errorf("v.SetBitArray(%v) == %s, expected %s", tc[0], v, tc[1])
		}
	}
}

func TestVector_PrettyString(t *testing.T) {
	var testCases = [][]interface{}{
		{nil, ""},
		{[]byte{}, ""},
		{[]byte{0}, "-"},
		{[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}, "1111111111111111--------11111111"},
		{[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}, "1111111111111111--------11111111----1111----1111--11--11--11--11"},
		{[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}, "1111111111111111--------11111111----1111----1111--11--11--11--11-1-1-1-1-1-1-1-1----111111111"},
	}
	for _, tc := range testCases {
		var v *Vector
		switch tc[0].(type) {
		case nil:
			v = new(Vector).SetBitArray(nil)
		default:
			v = new(Vector).SetBitArray(tc[0].([]byte))
		}
		if v.PrettyString() != tc[1].(string) {
			t.Errorf("v.PrettyString(%v) == %s, expected %s", tc[0], v, tc[1])
		}
	}
}

func TestVector_SetV(t *testing.T) {
	var testCases = []interface{}{
		nil,
		[]byte{},
		[]byte{0},
		[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		},
		[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		},
		[]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		},
	}
	for _, tc := range testCases {
		var v *Vector
		switch tc.(type) {
		case nil:
			v = new(Vector).SetBitArray(nil)
		default:
			v = new(Vector).SetBitArray(tc.([]byte))
		}
		w := new(Vector).SetV(v)
		if w.Cmp(v) != 0 {
			t.Errorf("w.SetV(%v) == %s, expected %s", v, w, v)
		}
	}
}

func TestVector_SetRandom(t *testing.T) {
	testCases := []uint{0, 1, 2, 10, 20, 30, 64, 128, 256, 127, 129, 2546789}
	for _, tc := range testCases {
		v := new(Vector).SetRandom(tc)
		if v.Len() != tc {
			t.Errorf("v.SetRandom(%d).Len() == %d, expected %d, v == %s", tc, v.Len(), tc, v)
		}
	}
}

func TestVector_Parse(t *testing.T) {
	var testCases = [][]string{
		{"", ""},
		{"-", "0"},
		{"111111111111111100-* * -* -1111       111 1",
			"11111111111111110000000011111111"},
		{"1111111111111111--0-0--*11111111- -0 -1111-0--1111--11--11--11--11",
			"1111111111111111000000001111111100001111000011110011001100110011"},
		{"-00*1111111111111111--0-0--*11111111- -0 -1111-0--1111--11--11--11--11",
			"00001111111111111111000000001111111100001111000011110011001100110011"},
		{"1111111111111111-00-*---11111111--*  - 1  1 11----1111--11--11--11--11-1-1-1-1-1-1-1-1----111111111",
			"111111111111111100000000111111110000111100001111001100110011001101010101010101010000111111111"},
		{"111111111111111100000000111111110000111100001111001100110011001101010101010101010000111111111",
			"111111111111111100000000111111110000111100001111001100110011001101010101010101010000111111111"},
	}
	for _, tc := range testCases {
		v, _ := new(Vector).Parse(tc[0])
		if v.String() != tc[1] {
			t.Errorf("v.Parse(%s) == %s, expected %s", tc[0], v, tc[1])
		}
	}
}

func TestVector_SetSupport(t *testing.T) {
	var testCases = [][]interface{}{
		{nil, uint(0), ""},
		{nil, uint(1), "0"},
		{[]uint{}, uint(0), ""},
		{[]uint{0}, uint(0), ""},
		{[]uint{0}, uint(1), "1"},
		{[]uint{1, 3, 5, 10}, uint(11), "01010100001"},
		{[]uint{1, 3, 5, 10}, uint(10), "0101010000"},
		{[]uint{
			7, 10, 14, 15, 17, 21, 23, 25, 26, 29, 30, 31, 32, 36, 39, 40, 42, 44, 46, 47, 48, 49,
			52, 53, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 75, 76,
		}, uint(80), "00000001001000110100010101100111100010011010101111001101111011111110111110011000"},
		{[]uint{
			7, 10, 14, 15, 17, 21, 23, 25, 26, 29, 30, 31, 32, 36, 39, 40, 42, 44, 46, 47, 48, 49,
			52, 53, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 75, 76,
		}, uint(61), "0000000100100011010001010110011110001001101010111100110111101"},
		{[]uint{
			7, 10, 14, 15, 17, 21, 23, 25, 26, 29, 30, 31, 32, 36, 39, 40, 42, 44, 46, 47, 48, 49,
			52, 53, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 75, 76,
		}, uint(65), "00000001001000110100010101100111100010011010101111001101111011111"},
		{[]uint{
			7, 10, 14, 15, 17, 21, 23, 25, 26, 29, 30, 31, 32, 36, 39, 40, 42, 44, 46, 47, 48, 49,
			52, 53, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 75, 76,
		}[5:6], uint(22), "0000000000000000000001"},
	}
	for _, tc := range testCases {
		var v *Vector
		switch tc[0].(type) {
		case nil:
			v = new(Vector).SetSupport(tc[1].(uint), nil)
		default:
			v = new(Vector).SetSupport(tc[1].(uint), tc[0].([]uint))
		}
		if v.String() != tc[2].(string) {
			t.Errorf("v.SetSupport(%d, %v) == %s, expected %s", tc[1], tc[0], v, tc[2])
		}
	}
}

func TestVector_And(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), New(), New()},
		{New(), new(Vector).SetBitArray([]byte{}), New()},
		{new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1}),
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
			1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1,
			1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
			1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
			0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0,
			1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).And(tc[0].(*Vector), tc[1].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("%s AND %s == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
		w = new(Vector).And(tc[1].(*Vector), tc[0].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("%s AND %s == %s, expected %s", tc[1], tc[0], w, tc[2])
		}
	}
}

func TestVector_Or(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), New(), New()},
		{New(), new(Vector).SetBitArray([]byte{}), New()},
		{new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1}),
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
			1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1,
			1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
			1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
			1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1,
			0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).Or(tc[0].(*Vector), tc[1].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("%s OR %s == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
		w = new(Vector).Or(tc[1].(*Vector), tc[0].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("%s OR %s == %s, expected %s", tc[1], tc[0], w, tc[2])
		}
	}
}

func TestVector_Xor(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), New(), New()},
		{New(), new(Vector).SetBitArray([]byte{}), New()},
		{new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1}),
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
			1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1,
			1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
			1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0,
			1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0,
			1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
			0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).Xor(tc[0].(*Vector), tc[1].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("%s XOR %s == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
		w = new(Vector).Xor(tc[1].(*Vector), tc[0].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("%s XOR %s == %s, expected %s", tc[1], tc[0], w, tc[2])
		}
	}
}

func TestVector_Not(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), New()},
		{new(Vector).SetBitArray([]byte{}), New()},
		{new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
			1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
			1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
			1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
			1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).Not(tc[0].(*Vector))
		if w.Cmp(tc[1].(*Vector)) != 0 {
			t.Errorf("NOT %s == %s, expected %s", tc[0], w, tc[1])
		}
	}
}

func TestXorWith1(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), New()},
		{new(Vector).SetBitArray([]byte{}), New()},
		{new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
			1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
			1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
			1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
			1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).Xor(tc[0].(*Vector), new(Vector).SetUnits(tc[0].(*Vector).Len()))
		if w.Cmp(tc[1].(*Vector)) != 0 {
			t.Errorf("%s XOR 1 == %s, expected %s", tc[0], w, tc[1])
		}
	}
}

func TestVector_Len(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), 0},
		{new(Vector).SetBitArray([]byte{}), 0},
		{new(Vector).SetBitArray([]byte{0}), 1},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), 32},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), 64},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), 93},
	}
	for _, tc := range testCases {
		w := tc[0].(*Vector).Len()
		if w != uint(tc[1].(int)) {
			t.Errorf("%s.Len() == %d, expected %d", tc[0], w, tc[1])
		}
	}
}

func TestVector_Support(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), []uint{}},
		{new(Vector).SetBitArray([]byte{}), []uint{}},
		{new(Vector).SetBitArray([]byte{0}), []uint{}},
		{new(Vector).SetBitArray([]byte{1}), []uint{0}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []uint{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
			13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), []uint{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
			13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31, 36,
			37, 38, 39, 44, 45, 46, 47, 50, 51, 54, 55, 58,
			59, 62, 63}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []uint{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
			13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31, 36,
			37, 38, 39, 44, 45, 46, 47, 50, 51, 54, 55, 58,
			59, 62, 63, 65, 67, 69, 71, 73, 75, 77, 79, 84,
			85, 86, 87, 88, 89, 90, 91, 92,
		}},
	}
	for _, tc := range testCases {
		w := tc[0].(*Vector).Support()
		for i, n := range tc[1].([]uint) {
			if i >= len(w) {
				t.Errorf("%s.Support() == %v, expected %v: differ length %d != %d",
					tc[0], w, tc[1], len(w), len(tc[1].([]uint)))
			}
			if w[i] != n {
				t.Errorf("%s.Support() == %v, expected %v: %d-th elements are differ %d != %d",
					tc[0], w, tc[1], i, w[i], n)
			}
		}
	}
}

func TestVector_Zeros(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), []uint{}},
		{new(Vector).SetBitArray([]byte{}), []uint{}},
		{new(Vector).SetBitArray([]byte{0}), []uint{0}},
		{new(Vector).SetBitArray([]byte{1}), []uint{}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []uint{16, 17, 18, 19, 20, 21, 22, 23}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), []uint{16, 17, 18, 19, 20, 21, 22, 23,
			32, 33, 34, 35, 40, 41, 42, 43,
			48, 49, 52, 53, 56, 57, 60, 61}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []uint{16, 17, 18, 19, 20, 21, 22, 23,
			32, 33, 34, 35, 40, 41, 42, 43,
			48, 49, 52, 53, 56, 57, 60, 61,
			64, 66, 68, 70, 72, 74, 76, 78,
			80, 81, 82, 83,
		}},
	}
	for _, tc := range testCases {
		w := tc[0].(*Vector).Zeros()
		for i, n := range tc[1].([]uint) {
			if i >= len(w) {
				t.Errorf("%s.Zeros() == %v, expected %v: differ length %d != %d",
					tc[0], w, tc[1], len(w), len(tc[1].([]uint)))
			}
			if w[i] != n {
				t.Errorf("%s.Zeros() == %v, expected %v: %d-th elements are differ %d != %d",
					tc[0], w, tc[1], i, w[i], n)
			}
		}
	}
}

func TestVector_Wt(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), 0},
		{new(Vector).SetBitArray([]byte{}), 0},
		{new(Vector).SetBitArray([]byte{0}), 0},
		{new(Vector).SetBitArray([]byte{1}), 1},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), 24},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), 40},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), 57},
	}
	for _, tc := range testCases {
		w := tc[0].(*Vector).Wt()
		if w != tc[1].(int) {
			t.Errorf("%s.Wt() == %v, expected %d", tc[0], w, tc[1])
		}
	}
}

func TestVector_Get(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), []byte{}},
		{new(Vector).SetBitArray([]byte{}), []byte{}},
		{new(Vector).SetBitArray([]byte{0}), []byte{0}},
		{new(Vector).SetBitArray([]byte{1}), []byte{1}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}},
	}
	for _, tc := range testCases {
		for i, n := range tc[1].([]byte) {
			if tc[0].(*Vector).Get(uint(i)) != n {
				t.Errorf("%s.Get(%d) == %d, expected %d",
					tc[0], i, tc[0].(*Vector).Get(uint(i)), n)
			}
		}
	}
}

func TestVector_Bits(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), []byte{}},
		{new(Vector).SetBitArray([]byte{}), []byte{}},
		{new(Vector).SetBitArray([]byte{0}), []byte{0}},
		{new(Vector).SetBitArray([]byte{1}), []byte{1}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}},
	}
	for _, tc := range testCases {
		w := tc[0].(*Vector).Bits()
		for i, n := range tc[1].([]byte) {
			if i >= len(w) {
				t.Errorf("%s.Bits() == %v, expected %v: differ length %d != %d",
					tc[0], w, tc[1], len(w), len(tc[1].([]uint)))
			}
			if w[i] != n {
				t.Errorf("%s.Bits() == %v, expected %v: %d-th elements are differ %d != %d",
					tc[0], w, tc[1], i, w[i], n)
			}
		}
	}
}

func TestVector_Iter(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), []byte{}},
		{new(Vector).SetBitArray([]byte{}), []byte{}},
		{new(Vector).SetBitArray([]byte{0}), []byte{0}},
		{new(Vector).SetBitArray([]byte{1}), []byte{1}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
		}},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), []byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}},
	}
	for _, tc := range testCases {
		i := 0
		for n := range tc[0].(*Vector).Iter() {
			if tc[1].([]byte)[i] != n {
				t.Errorf("%s.Iter(%d) == %d, expected %d",
					tc[0], i, n, tc[1].([]byte)[i])
			}
			i++
		}
	}
}

func TestVector_Concatenate(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), New(), New()},
		{New(), new(Vector).SetBitArray([]byte{}), New()},
		{new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1}),
			new(Vector).SetBitArray([]byte{0, 1})},
		{new(Vector).SetBitArray([]byte{1}),
			new(Vector).SetBitArray([]byte{0}),
			new(Vector).SetBitArray([]byte{1, 0})},
		{new(Vector).SetBitArray([]byte{
			0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
		}), new(Vector).SetBitArray([]byte{
			0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
		}), new(Vector).SetBitArray([]byte{
			0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1,
		}), new(Vector).SetBitArray([]byte{
			0, 1, 1, 0, 1, 1,
		}), new(Vector).SetBitArray([]byte{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).Concatenate(tc[0].(*Vector), tc[1].(*Vector))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("Concatenate(%s, %s) == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
	}
}

func TestVector_ShiftLeft(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), 10, New()},
		{new(Vector).SetBitArray([]byte{0}), 0,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{0}), 3,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{1}), 0,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{1}), 1,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{1}), 3,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 21, new(Vector).SetBitArray([]byte{
			1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 40, new(Vector).SetZero(40)},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,
			1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1,
			0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 28, new(Vector).SetBitArray([]byte{
			1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1,
			0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1,
			0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 64, new(Vector).SetZero(64)},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 28, new(Vector).SetBitArray([]byte{
			1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1,
			0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1,
			0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 67, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 80, new(Vector).SetZero(73)},
	}
	for _, tc := range testCases {
		w := new(Vector).ShiftLeft(tc[0].(*Vector), uint(tc[1].(int)))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("ShiftLeft(%s, %d) == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
	}
}

func TestVector_ShiftRight(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), 10, New()},
		{new(Vector).SetBitArray([]byte{0}), 0,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{0}), 3,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{1}), 0,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{1}), 1,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{1}), 3,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1,
			0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
			1, 1, 0, 0, 1, 1, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 21, new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 40, new(Vector).SetZero(40)},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1,
			0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
			1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1,
			0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 28, new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
			0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
			1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 64, new(Vector).SetZero(64)},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1,
			0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
			1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1,
			0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1,
			0, 0, 1, 1, 0, 1, 0, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 28, new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
			0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
			1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
			1, 0, 1, 0, 1, 0, 0, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 67, new(Vector).SetBitArray([]byte{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 1, 0, 0, 1, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 80, new(Vector).SetZero(73)},
	}
	for _, tc := range testCases {
		w := new(Vector).ShiftRight(tc[0].(*Vector), uint(tc[1].(int)))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("ShiftRight(%s, %d) == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
	}
}

func TestVector_RotateLeft(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), 10, New()},
		{new(Vector).SetBitArray([]byte{0}), 0,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{0}), 3,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{1}), 0,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{1}), 1,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{1}), 3,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,
			1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1,
			0, 0, 1, 1, 0, 1, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 21, new(Vector).SetBitArray([]byte{
			1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0,
			1, 1, 0, 0, 1, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 40, new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,
			1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1,
			0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 28, new(Vector).SetBitArray([]byte{
			1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1,
			0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1,
			0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0,
			0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 64, new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,
			1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1,
			0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0,
			1, 1, 0, 1, 0, 0, 1, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 28, new(Vector).SetBitArray([]byte{
			1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1,
			0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1,
			0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0,
			1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1,
			1, 1, 1, 0, 0, 0, 1, 0, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 67, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0,
			1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
			0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0,
			0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0,
			1, 1, 0, 0, 1, 0, 0, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 80, new(Vector).SetBitArray([]byte{
			1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
			0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
			0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1,
			1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0,
			1, 1, 1, 0, 0, 1, 0, 1, 1,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).RotateLeft(tc[0].(*Vector), uint(tc[1].(int)))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("RotateLeft(%s, %d) == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
	}
}

func TestVector_RotateRight(t *testing.T) {
	var testCases = [][]interface{}{
		{New(), 10, New()},
		{new(Vector).SetBitArray([]byte{0}), 0,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{0}), 3,
			new(Vector).SetBitArray([]byte{0})},
		{new(Vector).SetBitArray([]byte{1}), 0,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{1}), 1,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{1}), 3,
			new(Vector).SetBitArray([]byte{1})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1,
			0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
			1, 1, 0, 0, 1, 1, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 21, new(Vector).SetBitArray([]byte{
			1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0,
			1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1,
			0, 0, 1, 1, 0, 0, 1, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		}), 40, new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 1, new(Vector).SetBitArray([]byte{
			0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1,
			0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
			1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1,
			0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 28, new(Vector).SetBitArray([]byte{
			1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0,
			0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1,
			0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
			1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		}), 64, new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 1, new(Vector).SetBitArray([]byte{
			1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1,
			0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
			1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1,
			0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1,
			0, 0, 1, 1, 0, 1, 0, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 28, new(Vector).SetBitArray([]byte{
			1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0,
			0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1,
			0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
			1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
			1, 0, 1, 0, 1, 0, 0, 1, 0,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 67, new(Vector).SetBitArray([]byte{
			1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1,
			0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0,
			1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0,
			1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0,
			0, 1, 1, 1, 0, 0, 1, 0, 1,
		})},
		{new(Vector).SetBitArray([]byte{
			1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
			0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
			1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
			0, 1, 1, 0, 1, 0, 0, 1, 1,
		}), 80, new(Vector).SetBitArray([]byte{
			1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1,
			0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
			1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1,
			0, 1, 1, 0, 0, 1, 0, 0, 1,
		})},
	}
	for _, tc := range testCases {
		w := new(Vector).RotateRight(tc[0].(*Vector), uint(tc[1].(int)))
		if w.Cmp(tc[2].(*Vector)) != 0 {
			t.Errorf("RotateRight(%s, %d) == %s, expected %s", tc[0], tc[1], w, tc[2])
		}
	}
}
